<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Biplot logístico binario usando algoritmos de machine learning</title>
    <meta charset="utf-8" />
    <meta name="author" content="Giovany Babativa" />
    <meta name="author" content="Director: Jose Luis Vicente-Villardón" />
    <meta name="date" content="2020-07-20" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <script src="libs/xaringanExtra-logo/logo.js"></script>
    <script src="libs/xaringanExtra-webcam/webcam.js"></script>
    <script id="xaringanExtra-webcam-options" type="application/json">{"width":"200","height":"200","margin":"1em"}</script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/kePrint/kePrint.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Biplot logístico binario usando algoritmos de machine learning
## Trabajo de Fin de Máster
### Giovany Babativa
### Director: Jose Luis Vicente-Villardón
### 2020-07-20

---







<style>.panelset {
  --panel-tab-color-active: blue;
}</style>
<style type="text/css">
.xaringan-extra-logo {
  width: 110px;
  height: 128px;
  z-index: 0;
  background-image: url('https://upload.wikimedia.org/wikipedia/commons/6/6b/Logotipo_Universidad_de_Salamanca.svg');
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top:1em;right:1em;
}
</style>




# Objetivos

Implementar algunos algoritmos basados en el gradiente, libres del gradiente y métodos de cuasi-Newton para estimar los parámetros de un biplot logístico binario sin restricciones.

--

**Objetivos específicos**

-  Revisar en la literatura algunos algoritmos que sean libres del gradiente, otros que usen el gradiente y algunos basado en métodos de cuasi-Newton que permitan estimar los parámetros de un biplot logístico binario.

	
- Implementar los algoritmos en R para un biplot logístico binario y realizar una función que compare la convergencia y tiempo de procesamiento de los diferentes algoritmos.
	
- Escribir en R las funciones que permitan aplicar los algoritmos para estimar los parámetros y graficar el biplot asociado.
	
- Empaquetar las funciones diseñadas.
	
- Generar los archivos de ayuda para el manejo de las funciones dentro del paquete.
	
- Realizar una aplicación a un conjunto de datos para ilustrar los procedimientos y resultados.

---

# Introducción

Sea `\(\mathbf{X}=\left(\mathbf{x}_1, \ldots, \mathbf{x}_n\right)^T\)`, con `\(x_i \in \mathbb{R}^p\)`, `\(i=1, \ldots, n\)`, con `\(rank(\mathbf{X})=r\)`. La aproximación puede ser escrita como `\(\mathbf{X} = \mathbf{AB^{T}+E}\)` y que para un entero `\(k\leq r\)`, se define 

`$$\hat{\mathbf{X}} = \mathbf{U}_{(k)}\Lambda_{(k)}\mathbf{V}^T_{(k)}=\mathbf{AB}^T,$$` 
donde `\(\mathbf{U}_{(k)}=\left[\mathbf{u}_1, \ldots, \mathbf{u}_k\right]\)` y `\(\mathbf{V}=\left[\mathbf{v}_1, \ldots, \mathbf{v}_k\right]\)` son las matrices formadas por los `\(k\)` vectores singulares por izquierda y por derecha de la matriz `\(\mathbf{X}\)`; `\(\Lambda\)` es una matriz diagonal `\(k\)`-dimensional con los valores singulares ordenados de forma decreciente `\(\lambda_1\geq \ldots \geq \lambda_k &gt; 0\)`. 

Así el `\(ij\)`-ésimo elemento de la matriz denotado `\(x_{ij}\)` es aproximado por el producto `\(\mathbf{a^{T}_ib_j}\)`. Es usual utilizar una descomposición de valores singulares o métodos alternantes para la estimación de los marcadores de las filas y de las columnas.

---
# Biplot logístico binario


Sea `\(\mathbf{X}=\left(\mathbf{x}_1, \ldots, \mathbf{x}_n\right)^T\)`, una matriz binaria, con `\(x_i \in \mathbb{R}^p\)`, `\(i=1, \ldots, n\)` y `\(x_{ij} \sim Ber(\pi(\theta_{ij}))\)` con `\(\pi(\theta_{ij}) = \left\{1+exp(-\theta_{ij})\right\}^{-1}\)`, que representa la probabilidad de que la característica `\(j\)` se encuentre presente en el individuo `\(i\)`.

--
A partir de la distribución probabilidad se tiene
`$$P(X_{ij}=x_{ij}) = \pi(\theta_{ij})^{x_{ij}}\left( 1 - \pi(\theta_{ij})\right)^{1-x_{ij}}.$$`

--

La función de verosimilitud es
`$$\textit{L} (\mathbf{X}; \mathbf{\Theta}) = \prod_{i=1}^n\prod_{j=1}^p \pi(\theta_{ij})^{x_{ij}}\left( 1 - \pi(\theta_{ij})\right)^{1-x_{ij}}.$$`

--

Así log-verosimilitud se escribe como

`$$\mathcal{L}\left(\mathbf{\Theta}\right) = -\sum_{i=1}^n\sum_{j=1}^p \left[ x_{ij} log(\pi(\theta_{ij})) + (1-x_{ij})log(1-\pi(\theta_{ij}))\right].$$`

&lt;a name=cite-Villardon2006&gt;&lt;/a&gt;[Vicente-Villardón and Galindo (2006)](#bib-Villardon2006) usan un algoritmo de Newton-Raphson para estimar los parámetros, pero este enfoque eventualmente puede converger a mínimos locales.

---

# Biplot logístico binario

El log-odds de `\(\pi(\theta_{ij})\)` es `\(\theta_{ij}\)` con `\(\theta_{ij}=log\left\{\pi(\theta_{ij})/(1-\pi(\theta_{ij}))\right\}\)`, que corresponde al parámetro natural de una distribución Bernoulli expresada en forma de familia exponencial. La matriz canónica de parámetros naturales es `\(\mathbf{\Theta}=\left(\mathbf{\theta}_1, \ldots, \mathbf{\theta}_n \right)^T\)`  que se representa como

`$$\mathbf{\Theta} = f(\mu, \mathbf{A}, \mathbf{B}) = logit\left(\mathbf{\Pi}\right) = \mathbf{1}_n \mu^T + \mathbf{AB}^T,$$`

donde `\(\mathbf{\Theta} = logit(\mathbf{\Pi})\)` es un biplot en escala logit; `\(\mathbf{A}=\left(\mathbf{a_1, \ldots, a_n}\right)^T\)` con `\(\mathbf{a_i} \in \mathbb{R}^k, i=1, \ldots n\)`;  `\(\mathbf{B}=\left(\mathbf{b_1, \ldots, b_k}\right)\)` con `\(\mathbf{b_j} \in \mathbb{R}^p, j=1, \ldots k\)`; y `\(\mathbf{\Pi}=\pi\left(\mathbf{\Theta}\right)\)` es la matriz de valores predichos. 

--

La dirección `\(\mathbf{\beta}_j\)` que proyecta los marcadores de `\(\mathbf{A}\)` que predicen los valores de la columna `\(j\)` para una probabilidad fija `\(\pi\)` cuando `\(k=2\)` (&lt;a name=cite-Gower1996&gt;&lt;/a&gt;[Gower and Hand (1995)](#bib-Gower1996); [Vicente-Villardón and Galindo (2006)](#bib-Villardon2006)).

`$$d_1=\frac{(logit(\pi) - \mu_{j})b_{j1}}{\sum_{k=1}^2 b_{jk}^2}, \hspace{1cm} d_2=\frac{(logit(\pi) - \mu_{j})b_{j2}}{\sum_{k=1}^2 b_{jk}^2}.$$`

---

# Función de pérdida

`$$\mathcal{L}\left(\mathbf{\Theta}\right) = -\sum_{i=1}^n\sum_{j=1}^p \left[ x_{ij} log(\pi(\theta_{ij})) + (1-x_{ij})log(1-\pi(\theta_{ij}))\right] = \sum_{i=1}^n\sum_{j=1}^p f(\theta_{ij})$$`
--

Cuando la función de enlace logit es utilizada, `\(\pi(\theta_{ij})=(1-\exp(-\theta_{ij}))^{-1}\)`, de modo que el gradiente se obtiene como

`\begin{align}
\nabla f(\theta_{ij}) &amp; = -\left[x_{ij} \frac{1}{\pi(\theta_{ij})}\frac{\partial \pi(\theta_{ij}) }{\partial \theta_{ij}} + (1-x_{ij})\frac{1}{1-\pi(\theta_{ij})}\frac{\partial (1-\pi(\theta_{ij})) }{\partial \theta_{ij}}\right] \nonumber\\
&amp; = -\left[x_{ij} (1 - \pi(\theta_{ij}))  - (1-x_{ij})\pi(\theta_{ij})\right]\\
&amp; = \pi(\theta_{ij})-x_{ij}. \nonumber 
\end{align}`

--

De este modo, el gradiente de `\(\mathcal{L}\left(\mathbf{\Theta}\right)\)` se expresa en términos matriciales como

`$$\nabla \mathcal{L} = \mathbf{\Pi}  - \mathbf{X}.$$`

---
# Algoritmos implementados

Se desarrolló el paquete *BiplotML* que incluye 3 tipos de algoritmos
.pull-left[

&lt;img src="images/LogBipXDpto.png" width="90%" style="display: block; margin: auto;" /&gt;
]
--
.pull-right[ 

- Búsquedas sin usar el gradiente.
  - Nelder-Mead &lt;a name=cite-NeldMead65&gt;&lt;/a&gt;([Nelder and Mead, 1965](#bib-NeldMead65)).
  - uobyqa &lt;a name=cite-powell2002&gt;&lt;/a&gt;([Powell, 2002](#bib-powell2002)).
  - nweuoa &lt;a name=cite-powell2008&gt;&lt;/a&gt;([Powell, 2008](#bib-powell2008)). 
- Direcciones de búsqueda basadas en el gradiente.
  - Descenso del gradiente.
  - Gradiente Conjugado: Fletcher-Reeves, Polak-Ribiere, Beale-Sorenson, Dai-Yuan.
- Métodos de cuasi-Newton.
  - Broyden, Fletcher, Goldfarb y Shanno (BFGS).
]
---

# Paquete **BiplotML**


```r
install.packages("devtools")
devtools::install_github("jgbabativam/BiplotML")
library(BiplotML)
```

&lt;img src="images/GitHub.png" width="60%" style="display: block; margin: auto;" /&gt;

---
# Documentación del paquete


```r
?performanceBLB
```


.pull-left[
&lt;img src="images/help1.png" width="85%" style="display: block; margin: auto;" /&gt;
]
--
.pull-right[
&lt;img src="images/help2.png" width="85%" style="display: block; margin: auto;" /&gt;
]

---

#Algoritmo del descenso del gradiente

.pull-left[

El algoritmo se basa en actualizar cada parámetro `\(\mathbf{\Theta} = (\theta_{1},\ldots,\theta_n)^T\)` usando una velocidad o tasa de aprendizaje `\(\alpha\)`:

`\begin{align}
\mathbf{A}_{k+1} &amp; := \mathbf{A}_k + \alpha \left[\mathbf{\Pi} - \mathbf{X}\right]\mathbf{B}_k  \nonumber  \\
\mathbf{B}_{k+1} &amp; := \mathbf{B}_k + \alpha \left[\mathbf{\Pi} - \mathbf{X}\right]^T\mathbf{A}_k \\
\mu_{k+1} &amp; := \mu_k + \alpha \left[\mathbf{\Pi} - \mathbf{X}\right]^T\mathbf{1}_n \\
\mathbf{\Theta}_{k+1} &amp; = \mathbf{1}_n \mu^T_{k+1} + \mathbf{A_{k+1}B_{k+1}}^T
\end{align}`
]
--
.pull-right[ 

&lt;img src="images/gradient-descent.png" width="95%" style="display: block; margin: auto;" /&gt;
]

La cantidad de parámetros a estimar son `\(n k + p(k + 1)\)`.
La velocidad de aprendizaje, `\(\alpha\)` debe elegirse manualmente.

---
# Algoritmo del descenso del gradiente



.panelset[
.panel[.panel-name[Código en R]


```r
library(BiplotML)
data(Methylation)

set.seed(02052020)
outGD &lt;- gradientDesc(x = Methylation, k=2, rate = 0.001, converg=0.001, max_iter=10000)
```

```
[1] "The process converge with 220 iterations"
```
]

.panel[.panel-name[Marcadores]

El objeto de salida es una lista que contiene las matrices `\(\mathbf{A}\)` y `\(\mathbf{B}\)`, dentro de esta última, la primera columna corresponde a los efectos principales `\(\mu\)`. Acá `head(outGD$Ahat)` son los marcadores de las primeras 6 líneas celulares.

.pull-left[
&lt;table class="table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;"&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Dim1 &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Dim2 &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; AU565 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 0.791 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.750 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; BT-20 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 0.355 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1.042 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; BT-474 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 0.380 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1.004 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; BT-483 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1.275 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1.246 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; BT-549 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 0.369 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.979 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CAL-120 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 0.242 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1.073 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]

.pull-right[
&lt;table class="table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;"&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; `\(\mu\)` &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; `\(\mathbf{b_1}\)` &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; `\(\mathbf{b_2}\)` &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; GSTM1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3.049 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 2.132 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 2.123 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; C1orf70 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3.342 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 2.210 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1.670 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; DNM3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3.106 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 2.041 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 2.069 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; THY1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 2.279 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1.024 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1.698 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; ADCY4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1.663 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.847 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1.540 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; GSTT1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; -1.322 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; -0.603 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; -0.653 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
] 

]

.panel[.panel-name[Biplot]


```
[1] "The process converge with 220 iterations"
```

&lt;img src="figs/unnamed-chunk-10-1.png" width="40%" style="display: block; margin: auto;" /&gt;
]
]
---
# Velocidad de aprendizaje

![](images/gradient-descent2.png)

--

- Estrategia de búsqueda en línea: `\(\min_{\alpha &gt; 0} \mathcal{L}\left(\mathbf{\Theta} + \alpha d_k \right).\)`
- Condiciones de Wolfe: condición de Armijo y de curvatura.

---
# Algoritmos basados en el gradiente conjugado

1. Partir de un punto `\(\mathbf{\theta}_0\)`.
2. A partir del gradiente identificar la dirección de descenso con mayor pendiente, `\(d^T_k\)`, 
3. Usando una búsqueda en línea, calcular `\(\alpha_k\)` para identificar el mínimo aproximado de `\(\mathcal{L}\left(\mathbf{\Theta}\right)\)` a lo largo de `\(d_k\)`, garantizando que se cumplan las _condiciones de Wolfe_.
4. Usar un parámetro `\(\beta_k\)` como regla para la actualización de la dirección basada en el gradiente. 

5. Actualizar de forma simultánea al espacio natural de parámetros `\(\mathbf{\Theta}\)`, que se obtiene al actualizar `\(\mu\)`, `\(\mathbf{A}\)` y `\(\mathbf{B}\)`.

--

Por ejemplo, para la matriz de marcadores fila, el algoritmo se actualiza en el paso `\(k+1\)` como
`$$\mathbf{A}_{k + 1} = \mathbf{A}_k + \alpha_k d_k,$$`
donde
`\begin{equation}
d_k = \begin{cases} - \nabla \mathcal{L}_k \hspace{3.0cm} \text{si } k=0, \\ - \nabla \mathcal{L}_k + \beta_kd_{k-1} \hspace{0.5cm} \text{si } k \geq 1,  \end{cases} 
\end{equation}`

con `\(\nabla \mathcal{L}_k = \nabla \mathcal{L}\left(\mathbf{\Theta}_k\right)\)`; `\(\beta_k\)` es un escalar y `\(\alpha_k &gt; 0\)` es la velocidad de aprendizaje obtenida por una búsqueda en línea y requiere que se cumplan las _condiciones fuertes de Wolf_ 
---

# Algoritmos basados en el gradiente conjugado

El paquete **BiplotML** cuenta con la implementación de los algoritmos del gradiente conjugado para un biplot logístico binario, el usuario tiene la opción de elegir entre el método de Fletcher-Reeves (FR), Polak-Ribiere-Polyak (PRP), Hestenes-Stiefel (HS) y Dai-Yuan (DY).


`\begin{align}
\beta_k^{FR}=\frac{\left\lVert \nabla \mathcal{L}_k\right\rVert^2}{\left\lVert \nabla \mathcal{L}_{k-1} \right\rVert^2}; \hspace{0.5cm} \beta_k^{PRP}=\frac{\nabla \mathcal{L}_k^T\Delta_{k-1}}{\left\lVert \nabla \mathcal{L}_{k-1} \right\rVert^2}; \\ 
\beta_k^{HS}=\frac{\nabla \mathcal{L}_k^T\Delta_{k-1}}{d_{k-1}^T\Delta_{k-1}}; \hspace{0.5cm} \beta_k^{DY}=\frac{\left\lVert \nabla \mathcal{L}_k\right\rVert^2}{d_{k-1}^T\Delta_{k-1}} \hspace{0.5cm} . 
\end{align}`

donde `\(\Delta_{k-1}=\nabla \mathcal{L}_k-\nabla \mathcal{L}_{k-1}\)` y `\(\left\lVert \cdot  \right\rVert\)` se refiere a la norma euclideana.

---

# Algoritmo del gradiente conjugado



.panelset[
.panel[.panel-name[Código en R]


```r
#... Fletcher-Reeves (FR)
LogBip.FR &lt;- bootBLB(x = Methylation, method = "CG", type = 1, ellipses = FALSE)

#... Polak-Ribiere-Polyak
LogBip.PR &lt;- bootBLB(x = Methylation, method = "CG", type = 2, ellipses = FALSE)
```
]

.panel[.panel-name[Biplot]

.pull-left[
&lt;img src="figs/unnamed-chunk-11-1.png" width="85%" style="display: block; margin: auto;" /&gt;
]

.pull-right[
&lt;img src="figs/unnamed-chunk-12-1.png" width="85%" style="display: block; margin: auto;" /&gt;
] 

]

.panel[.panel-name[Ajuste]

&lt;table class="kable_wrapper table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;"&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td&gt; 

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Sensitivy &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Specificity &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Global &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; GSTM1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 75.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 93.8 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; C1orf70 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 97.9 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; DNM3 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 87.5 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; THY1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 80.5 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 83.3 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; ADCY4 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 80.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 91.7 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; GSTT1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 25.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 4.2 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 60.4 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; FILIP1L &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 80.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 85.4 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; DUSP22 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 90.6 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 31.2 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 83.3 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; NAPRT1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 31.2 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 89.6 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 &lt;/td&gt;
   &lt;td&gt; 

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Sensitivy &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Specificity &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Global &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; GSTM1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 50.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 95.8 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; C1orf70 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 97.9 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; DNM3 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 66.7 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 91.7 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; THY1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 78.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 28.6 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 77.1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; ADCY4 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 60.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 93.8 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; GSTT1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 83.3 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 91.7 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; FILIP1L &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 77.1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 15.4 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 79.2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; DUSP22 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 78.1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 25.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 77.1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; NAPRT1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 90.6 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 62.5 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 72.9 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]
]

---
# Algoritmo BFGS

Se considera un modelo cuadrático de la función de pérdida en la iteración `\(k\)`
`$$m_k(d) = \mathcal{L}_k + \nabla \mathcal{L}_k^T d + \frac{1}{2} d^T B_k d$$`

--

`\(B_k\)` es una matriz definida positiva que se actualiza en cada iteración. La dirección de actualización en el paso `\(k\)` es
`$$\mathbf{\Theta}_{k+1} = \mathbf{\Theta}_k + \alpha_k d_k,$$`
donde `\(d_k =  -B_k^{-1} \nabla  \mathcal{L}_k\)` y `\(\alpha_k\)` la velocidad de aprendizaje que satisface las _condiciones de Wolfe_.

--

Usando la formula de Broyden, Fletcher, Goldfarb y Shanno (BFGS), la actualización para el biplot logístico binario es

`$$B_{k+1} = B_{k} - \frac{B_k s_k s_k^T B_k}{s_k^T B_k s_k} + \frac{\Delta_k \Delta_k^T}{\Delta_k^T s_k},$$`
con `\(\Delta_k = \nabla \mathcal{L}_{k+1} - \nabla \mathcal{L}_{k}\)` y `\(s_k = \mathbf{\Theta}_{k+1} - \mathbf{\Theta}_{k} = \alpha_k d_k\)`.
---

# Algoritmo BFGS



.panelset[
.panel[.panel-name[Código R]


```r
#... BFGS algorithm
set.seed(02052020)
res.LB &lt;- LogBip(x = Methylation, method = "BFGS")
```

La función cuenta con otros argumentos
- `label.ind = TRUE`: Etiqueta a los marcadores fila.
- `col.ind`: Factor para agregar un color a los marcadores fila.
- `endsegm`: Por defecto en 0.75. 
- `draw = c("biplot", "ind", "var")`: Por defecto devuelve el biplot.

Y otros más que están documentados en `help(LogBip)`. 
]

.panel[.panel-name[Biplot]

&lt;img src="figs/unnamed-chunk-14-1.png" width="45%" style="display: block; margin: auto;" /&gt;
]

.panel[.panel-name[Ajuste]

&lt;table class="table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;"&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Sensitivy &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Specificity &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Global &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; GSTM1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 43.2 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 47.9 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; C1orf70 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 53.2 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 54.2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; DNM3 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 83.3 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 85.4 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; THY1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 39.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 47.9 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; ADCY4 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 40.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 93.8 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; GSTT1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 87.5 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 62.5 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 75.0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; FILIP1L &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 40.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 92.3 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 54.2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; DUSP22 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 90.6 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 68.8 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 83.3 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; NAPRT1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 37.5 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 100.0 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 58.3 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]
]
---

# Convergencia y tiempo de procesamiento



.panelset[
.panel[.panel-name[Código R]

Para comparar el desempeño computacional de los diferentes algoritmos, el paquete *BiplotML* cuenta la función `performanceBLB()` que permite comparar tiempo de procesamiento y evaluar la convergencia de los algoritmos.


```r
data('Methylation')
set.seed(02052020)

########### Without Gradient Methods
performanceBLB(xi = Methylation, method = 1, maxit = 100)

########### Gradient Methods
performanceBLB(xi = Methylation, maxit = 150)

########### Quasi-Newton Methods
performanceBLB(xi = Methylation, method = 3)

########### All methods
performanceBLB(x = Methylation, method = 4)
```
]

.panel[.panel-name[Desempeño]

&lt;table class="table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;"&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:center;"&gt; method &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; evaluat &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; convergence &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; fevals &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; time &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; Nelder-Mead &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 244.79 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; max iterations &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 502 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.17 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; CG &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 64.20 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; max iterations &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 237 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.12 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; BFGS &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 45.18 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; max iterations &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 247 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.17 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; nlm &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 56.20 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; max iterations &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; NA &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.23 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; nlminb &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 43.68 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; max iterations &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 200 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.16 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; Rcgmin &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 47.42 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; max iterations &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1105 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.73 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; newuoa &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 54.57 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; convergence &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 55000 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 44.29 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]
]

---
# Inferencia




.panelset[
.panel[.panel-name[Bootstrap]

&lt;img src="images/AlgoBootstrap.png" width="70%" style="display: block; margin: auto;" /&gt;

]

.panel[.panel-name[Elipses]

&lt;img src="images/AlgoRegion.png" width="75%" style="display: block; margin: auto;" /&gt;
La función `bootBLB()` del paquete **BiploML** permite dibujar las regiones de confianza usando el argumento `ellipses = TRUE`.
]
]
---

# Inferencia


```r
data("Methylation")
set.seed(02052020)
LogBip.FR &lt;- bootBLB(x = Methylation, method = "CG", type = 1, ellipses = TRUE)
```

&lt;img src="figs/unnamed-chunk-20-1.png" width="40%" style="display: block; margin: auto;" /&gt;

---

# Aplicación

Se usaron los datos del [Genomic Determinants of Sensitivity in Cancer 1000 (GDSC1000)](https://www.cancerrxgene.org/gdsc1000/GDSC1000_WebResources/Home.html) de la investigación de `Iorio y col. (2016)`. Los datos contienen información sobre líneas celulares de cáncer provenientes de más de 11 mil tumores. Luego de un preprocesamiento, las muestras se resumieron en 1.001 líneas celulares para 30 tipos de cáncer que integran mutaciones somáticas, copia del número de alteraciones (CNA), metilaciones del DNA y cambios de expresión de génes. 

--

Para facilitar la interpretación se eligieron 3 tipos de cáncer:

- *BRCA*: Cáncer de mama.
- *LUAD*: Adenocarcinoma pulmonar que es un tipo de cáncer de pulmón.
- *SKCM*: Melanoma de piel; es uno de los cánceres de piel más agresivos.

Las tres matrices de interés con la información para los tres tipos de cáncer, quedaron con 160 líneas celulares, donde el conjunto de datos de mutación contiene 197 variables, mientras que el de CNA contiene 412 variables y el de mutación tiene 38 variables.

---

# Resultados Metilación: CG - Fletcher-Reeves



.panelset[
.panel[.panel-name[Código R]


```r
library(BiplotML)
set.seed(1234)
#... Plano de los marcadores fila
Met.FR &lt;- LogBip(xMethy %&gt;% select(-`Cancer Type`), 
                 col.ind = xMethy$`Cancer Type`, endsegm = 0.90, draw = "ind")

#... Biplot
set.seed(1234)
bMet.FR &lt;- LogBip(xMethy %&gt;% select(-`Cancer Type`), 
                 col.ind = xMethy$`Cancer Type`, endsegm = 0.90)
```

]

.panel[.panel-name[Filas]

&lt;img src="images/MethysInd.png" width="50%" style="display: block; margin: auto;" /&gt;

]

.panel[.panel-name[Biplot]

&lt;img src="images/MethysEjemplo.png" width="50%" style="display: block; margin: auto;" /&gt;
]
]


---

# Resultados Metilación: CG - Polak-Ribiere



.panelset[
.panel[.panel-name[Código R]


```r
library(BiplotML)
set.seed(1234)
#... Plano de los marcadores fila
Met.PR &lt;- LogBip(xMethy %&gt;% select(-`Cancer Type`), 
                 col.ind = xMethy$`Cancer Type`, endsegm = 0.90, type = 2, draw = "ind")

#... Biplot
set.seed(1234)
bMet.PR &lt;- LogBip(xMethy %&gt;% select(-`Cancer Type`), 
                  col.ind = xMethy$`Cancer Type`, endsegm = 0.90, type = 2)
```

]

.panel[.panel-name[Filas]

&lt;img src="images/MethysIndPolak.png" width="50%" style="display: block; margin: auto;" /&gt;

]

.panel[.panel-name[Biplot]

&lt;img src="images/MethysEjemploPolak.png" width="50%" style="display: block; margin: auto;" /&gt;
]
]

---

# Resultados Metilación: BFGS



.panelset[
.panel[.panel-name[Código R]


```r
library(BiplotML)
set.seed(1234)
#... Plano de los marcadores fila
Met.BFGS &lt;- LogBip(xMethy %&gt;% select(-`Cancer Type`), 
                    col.ind = xMethy$`Cancer Type`, method = "BFGS", endsegm = 0.90, draw = "ind")

#... Biplot
set.seed(1234)
bMet.BFGS &lt;- LogBip(xMethy %&gt;% select(-`Cancer Type`), 
                    col.ind = xMethy$`Cancer Type`, method = "BFGS", endsegm = 0.90)
```

]

.panel[.panel-name[Filas]

&lt;img src="images/MethysIndBFGS.png" width="50%" style="display: block; margin: auto;" /&gt;

]

.panel[.panel-name[Biplot]

&lt;img src="images/MethysEjemploBFGS.png" width="50%" style="display: block; margin: auto;" /&gt;
]
]
---

# Estadísticos de ajuste



.panelset[
.panel[.panel-name[Ajuste]

&lt;img src="images/resumenMethys.png" width="75%" style="display: block; margin: auto;" /&gt;

]

.panel[.panel-name[Plot]

&lt;img src="images/BoxPlotMethys.png" width="60%" style="display: block; margin: auto;" /&gt;

]

.panel[.panel-name[Código R]


```r
fit &lt;- bind_rows(list(Met.FR$fit %&gt;% mutate(Algorithm = "F.R"),
                      Met.PR$fit %&gt;% mutate(Algorithm = "P.R"),
                      Met.BFGS$fit %&gt;% mutate(Algorithm = "BFGS")))

stat.sens &lt;- fit %&gt;% group_by(Algorithm) %&gt;% 
             summarise(media = mean(Sensitivy),
                       sd = sd(Sensitivy),
                       min = min(Sensitivy),
                       P5 = quantile(Sensitivy, 0.05),
                       P25 = quantile(Sensitivy, 0.25),
                       P50 = quantile(Sensitivy, 0.50),
                       P75 = quantile(Sensitivy, 0.75)) %&gt;% 
             ungroup() %&gt;% 
             tibble::column_to_rownames("Algorithm")

tstat.sens &lt;- data.table::transpose(stat.sens)
colnames(tstat.sens) &lt;- rownames(stat.sens)
rownames(tstat.sens) &lt;- colnames(stat.sens)
```

]
]


---

# Conclusiones 

1. Se escribió el paquete *BiplotML* donde se implementaron más de 10 algoritmos de estimación.

2. Se describen los procedimientos matemáticos que permiten adaptar los algoritmos del descenso del gradiente, cuatro fórmulas que usan el gradiente conjugado y el algoritmo de cuasi-Newton de Broyden, Fletcher, Goldfarb y Shanno (BFGS), para un biplot logístico binario.

3. Se propuso y se implementó una metodología de bootstrap no paramétrico para realizar la inferencia de los resultados obtenidos con un biplot logístico binario.

4. La función `performanceBLB()` que permite comparar la convergencia y el tiempo de procesamiento de los diferentes algoritmos.

5. Se usaron datos reales sobre mutaciones somáticas, copia del número de alteraciones (CNA) y metilaciones del DNA, provenientes de más de 11 mil tumores para 30 tipos de cáncer.

---

# Referencias

&lt;a name=bib-Gower1996&gt;&lt;/a&gt;[Gower, J. C. and D. J.
Hand](#cite-Gower1996) (1995). _Biplots_. Vol. 54. CRC Press.

&lt;a name=bib-NeldMead65&gt;&lt;/a&gt;[Nelder, J. A. and R.
Mead](#cite-NeldMead65) (1965). "A simplex method for function
minimization". In: _Computer Journal_ 7, pp. 308-313.

&lt;a name=bib-powell2002&gt;&lt;/a&gt;[Powell, M. J.](#cite-powell2002) (2002).
"UOBYQA: unconstrained optimization by quadratic approximation". In:
_Mathematical Programming_ 92.3, pp. 555-582.

&lt;a name=bib-powell2008&gt;&lt;/a&gt;[Powell, M. J.](#cite-powell2008) (2008).
"Developments of NEWUOA for minimization without derivatives". In: _IMA
journal of numerical analysis_ 28.4, pp. 649-664.

&lt;a name=bib-Villardon2006&gt;&lt;/a&gt;[Vicente-Villardón, J. and M. P.
Galindo](#cite-Villardon2006) (2006). "Logistic Biplots". In: _Multiple
Correspondence Analysis and related Methods_. Chapman-Hall. Chap. 23,
pp. 503-521. ISBN: 9780470973196.

---

class: center, middle

# Gracias!

Diapositivas realizadas con el paquete R [**xaringan**](https://github.com/yihui/xaringan).
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "dracula",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
